%!TEX root = ../dokumentation.tex

\chapter{Algorithmen die das Rucksackproblem lösen}
Algorithmen, die das Rucksackproblem lösen können in zwei Kategorien 
eingeteilt werden: Algorithmen, die immer die Optimale Lösung finden, 
dafür aber eine inakzeptable Zeitkomplexität haben, 
oder Algorithmen mit geringerer Zeitkomplexitätsklasse, die 
aber nicht für eine Optimale Lösung garantieren.

\section{Algorithmen mit Suchbaum}
\subsection{Brute-Force Algorithmus}
Die Lösung des Rucksackproblems mithilfe des 
Brute-Force-Algorithmus ist eine naive, aber grundlegende 
Methode, um die optimale Lösung zu finden. Dieser Ansatz 
basiert auf der systematischen Überprüfung aller möglichen 
Kombinationen von Gegenständen, um diejenige zu finden, die 
den größtmöglichen Wert bei Einhaltung der Kapazitätsgrenze 
des Rucksacks bietet.

Um den Brute-Force-Algorithmus mathematisch zu beschreiben, 
müssen zuerst die Eingabeparameters des Problems beachtet werden. Sei 
$N$ die Gesamtanzahl der verfügbaren Gegenstände. Jeder 
Gegenstand $i$ hat einen bestimmten Wert $v_i$ und ein Gewicht $wi$. 
Der Rucksack hat eine maximale Kapazität $W$.

Der Brute-Force-Algorithmus durchläuft nun alle $2^N$ möglichen 
Kombinationen der Entscheidungsvariablen $x_i$. Für jede 
Kombination wird das Gewicht überprüft, um sicherzustellen, 
dass die Kapazitätsgrenze des Rucksacks eingehalten wird. 
Wenn dies der Fall ist, wird der Wert dieser Kombination 
berechnet und mit dem bisher besten Wert verglichen. Der 
Brute-Force-Algorithmus speichert die beste Kombination von 
Gegenständen, die den höchsten Wert erzielt.

Die Laufzeitkomplexität des Brute-Force-Algorithmus beträgt 
$O(2^N)$, da der Algorithmus alle möglichen Kombinationen der 
Gegenstände durchläuft. Diese exponentielle Komplexität 
macht den Brute-Force-Algorithmus für große $N$ unpraktikabel.

Trotz seiner ineffizienten Laufzeit hat der 
Brute-Force-Algorithmus einige Vorteile. Er liefert immer die 
optimale Lösung, da er alle möglichen Kombinationen überprüft.
\subsection{Branch-Bound Algorithmus}
Zuerst wird die Entscheidungsvariable $x_i$ für jeden 
Gegenstand $i$ definiert. Wenn Gegenstand $i$ ausgewählt wird, ist $x_i$ 
gleich $1$, andernfalls ist $x_i$ gleich $0$. Darüber hinaus 
verwenden wird die Funktion $f(x)$ zur Berechnung des 
Gesamtwerts einer Teilmenge von Gegenständen $x$ und die 
Funktion $g(x)$ zur Berechnung des Gesamtgewichts einer 
Teilmenge von Gegenständen $x$ verwendet.

Der Branch-and-Bound-Algorithmus beginnt mit einer 
Anfangslösung, die keinen Gegenstand enthält 
$(x = {0, 0, \cdots, 0})$. Anschließend wird ein Suchbaum 
aufgebaut, der alle möglichen Teilräume des Lösungsraums 
repräsentiert. Jeder Knoten im Suchbaum entspricht einer 
Teilmenge von Gegenständen. Der Algorithmus durchläuft den 
Suchbaum rekursiv, indem er Teilräume basierend auf 
Schätzungen und Grenzwerten erzeugt und abschneidet.

Die Schätzungsfunktion $E(xs)$ wird verwendet, um eine obere 
Schranke für den Wert einer Teilmenge von Gegenständen x zu 
berechnen. Diese Schätzung basiert auf einer Relaxation des 
Rucksackproblems, bei der angenommen wird, dass beliebige 
Bruchteile von Gegenständen ausgewählt werden können. Eine 
mögliche Schätzungsfunktion ist:

\begin{equation}
    E(x) = f(x) + (W - g(x)) \cdot \left(\frac{v_{i+1}}{w_{i+1}}\right)
\end{equation}

wobei $i$ der Index des nächsten Gegenstands ist, der nicht 
in $x$ enthalten ist. Diese Schätzung beruht auf der Annahme, 
dass der nächste Gegenstand mit dem höchsten Verhältnis von 
Wert zu Gewicht ausgewählt wird, um die verbleibende 
Kapazität optimal auszunutzen.

Basierend auf der Schätzungsfunktion wird ein Grenzwert 
(bound) für den aktuellen Teilraum berechnet. Der Grenzwert 
$B(x)$ wird definiert als der maximale Wert, der in einem 
Teilraum von Gegenständen x erreicht werden kann, ohne das 
Gewichtslimit zu überschreiten. Der Grenzwert $B(x)$ wird 
rekursiv berechnet, indem alle Teilräume des aktuellen 
Teilraums betrachtet werden. Wenn ein Teilraum das 
Gewichtslimit überschreitet, wird der Grenzwert auf den Wert 
des aktuellen Teilraums gesetzt. Andernfalls wird der 
Grenzwert als die maximale Summe der Werte aller Gegenstände 
im Teilraum plus der maximalen Summe der Werte, die aus dem 
Rest des Rucksacks ausgewählt werden können, berechnet.

Der Branch-and-Bound-Algorithmus verwendet eine Tiefensuche, 
um den Suchbaum zu durchlaufen. Bei jedem Schritt wird ein 
Knoten ausgewählt und seine Kinderknoten generiert. Die 
Kinderknoten entsprechen den Teilräumen, die durch 
Hinzufügen oder Nicht-Hinzufügen des nächsten Gegenstands 
entstehen. Die Kinderknoten werden nach ihrem Grenzwert 
sortiert, und nur die vielversprechendsten Knoten werden 
weiter erkundet, während unproduktive Knoten abgeschnitten 
werden.

Der Algorithmus terminiert, wenn alle Knoten des Suchbaums 
erkundet wurden. Die optimale Lösung ist der Knoten mit dem 
höchsten Gesamtwert. Der Branch-and-Bound-Algorithmus 
gewährleistet die Rückgabe einer optimalen Lösung, da er 
systematisch den Suchraum durchsucht und unproduktive 
Teilräume abschneidet.

Es ist wichtig anzumerken, dass die Laufzeit des 
Branch-and-Bound-Algorithmus stark von der Größe des 
Suchraums abhängt. In einigen Fällen kann der Algorithmus 
sehr zeitaufwändig sein, insbesondere wenn die Anzahl der 
Gegenstände groß ist. Daher werden häufig Optimierungen wie 
Heuristiken und Relaxationen verwendet, um die Laufzeit zu 
verbessern.\ \cite[vgl.]{Martello1987}
\section{Greedy-Algorithmus}
Der Greedy-Algorithmus zur Lösung des Rucksackproblems besteht 
aus fünf Schritten:

Schritt 1: Berechne das Verhältnis von Wert zu Gewicht für 
jeden Gegenstand.
Verhältnis \[r_i = \frac{v_i}{w_i}\]

Schritt 2: Sortiere die Gegenstände absteigend nach ihrem 
Verhältnis von Wert zu Gewicht.
\[r_1 \geq r_2 \geq \cdots \geq r_n\]

Schritt 3: Initialisiere den Rucksack und den Gesamtwert.
\[   \text{rucksack} = \{\}; \\
    \text{wert} = 0 \]
Schritt 4: Durchlaufe die sortierte Liste der Gegenstände.\\
Für $i = 1$ bis $n$: 
Wenn das Hinzufügen des Gegenstands $i$ zum Rucksack den 
verbleibenden Platz im Rucksack nicht überschreitet:
Füge den Gegenstand $i$ zum Rucksack hinzu.
Aktualisiere den verbleibenden Platz im Rucksack.
Erhöhe den Gesamtwert um den Wert des Gegenstands $i$.

Schritt 5: \\Gib den Rucksack und den Gesamtwert als Ergebnis 
aus.

Der Greedy-Algorithmus basiert auf der Annahme, dass es 
immer optimal ist, den Gegenstand mit dem höchsten Verhältnis 
von Wert zu Gewicht zu wählen. Diese Annahme kann bei dem Rucksackproblem
keine optimale Lösung Garantieren.

Um dies zu beweisen, betrachten wir ein einfaches Beispiel: 
Gegeben seien drei Gegenstände mit den Werten $v = \{60, 100, 120\}$ 
und den Gewichten $w =\{10, 20, 30\}$. Der Rucksack hat eine Kapazität 
von $W = 50$. Der Greedy-Algorithmus würde den Gegenstand 1 mit 
dem höchsten Verhältnis von Wert zu Gewicht auswählen. Die Optimale 
Lösung lässt Gegenstand 1 aus dem Rucksack und nimmt nur Gegenstand 2 und 3.
Damit ist gezeigt, dass der Greedy-Ansatz nicht für eine optimale Lösung 
garantieren kann.

Die Zeitkomplexität des Greedy-Algorithmus zur Lösung des 
Rucksackproblems ist $O(nlog(n))$, 
wobei $n$ die Anzahl der Gegenstände darstellt. Dabei nimmt das 
sortieren der Liste der Gegenstände die meiste Zeit ein, bzw.\ hat 
die Höchste Zeitkomplexität, weil das Sortieren einer Liste 
keine geringere Zeitkomplexität als $(nlog(n))$ haben kann 
\todo{citation needed}. Der Rest des Greedy"=Algorithmus hat eine 
Laufzeit von $O(n)$.\ \cite[vgl.]{cormen2022introduction}

\section{Dynamische Programmierung}
Die dynamische Programmierung ist eine effiziente Methode zur 
Lösung des Rucksackproblems, bei der das Problem in kleinere 
Teilprobleme aufgeteilt wird und die Lösungen der Teilprobleme 
abgespeichert werden, um mögliche Überlappungen zu vermeiden, falls 
diese Teilprobleme erneut berechnet werden müssten.

Um das Rucksackproblem mit dynamischer Programmierung zu 
lösen, müssen zuerst die Teilprobleme betrachtet werden. Sei $n$ die 
Anzahl der verfügbaren Gegenstände und $M$ die Kapazität des 
Rucksacks. Wir definieren eine Tabelle $dp$, die die maximale 
Gesamtwertsumme für jede Teilmenge der Gegenstände und jede 
mögliche Kapazität des Rucksacks speichert. Die Einträge in 
der Tabelle werden durch $dp[i][j]$ repräsentiert, wobei $i$ den 
Index des aktuellen Gegenstands und $j$ die aktuelle Kapazität 
des Rucksacks darstellt.

Um den Wert in $dp[i][j]$ zu berechnen, betrachtet der Algorithmus 
zwei Möglichkeiten: entweder der $i$-te Gegenstand wird in den 
Rucksack aufgenommen oder nicht. Wenn der $i$-te Gegenstand 
nicht aufgenommen wird, bleibt der Wert $dp[i][j]$ gleich 
$dp[i-1][j]$. Falls der $i$-te Gegenstand aufgenommen wird, wird 
der Gesamtwert um den Wert des $i$-ten Gegenstands erhöht, und 
die verbleibende Kapazität des Rucksacks wird um das Gewicht 
des $i$-ten Gegenstands reduziert. Der Wert $dp[i][j]$ wird dann 
zu $dp[i-1][j-w[i]] + v[i]$, wobei $w[i]$ das Gewicht und $v[i]$ 
der Wert des $i$-ten Gegenstands ist.

Der Basisfall der dynamischen Programmierung tritt ein, wenn 
entweder $i \le 0$ oder $j = 0$ ist. $i \le 0$ referenziert einen 
Gegenstand ausserhalb der Liste, weshalb $dp[0][j]$ für alle j gleich 0 ist. 
Der Fall $j = 0$ bedeutet, 
dass der Rucksack keine Kapazität mehr hat und $dp[i][0]$ 
für alle $i$ gleich $0$ ist.

Der rekursive Zusammenhang der dynamischen Programmierung 
kann durch folgende Formel ausgedrückt werden:

\begin{equation}
    \text{dp}[i][j] = \begin{cases}
        \max(\text{dp}[i-1][j], \text{dp}[i-1][j-w[i]] + v[i]), & \text{wenn } j \geq w[i] \\
        \text{dp}[i-1][j], & \text{wenn } j < w[i]
    \end{cases}
\end{equation}


Der Wert in $dp[n][M]$ gibt die maximale Gesamtwertsumme an und 
repräsentiert somit die optimale Lösung des Rucksackproblems.

Die Laufzeit dieses Algorithmus beträgt $O(nM)$, da 
eine Tabelle der Größe $(n+1) × (M+1)$ erstellt wird und 
jeder Eintrag der Tabelle in konstanter Zeit berechnet wird.\ \cite[vgl.]{Martello1987}